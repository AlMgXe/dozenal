#!/usr/bin/perl
# +AMDG  This document was begun on 8 Sept 11E8, the feast
# of the Nativity of the Blessed Virgin Mary and the Comm.
# of St. Hadrian, Martyr, and it is humbly dedicated to them
# for their prayers, and to the Sacred Heart of Jesus for
# His mercy.

use strict;
use POSIX;
use String::Escape qw (unbackslash backslash);
use Time::Piece;
#use List::MoreUtils;
use Date::Day;
use Date::Easter;
use Date::Pcalc qw(:all);
use Getopt::Std;
getopts('f:d:o:thcl');
our($opt_f,$opt_d,$opt_o,$opt_t,$opt_h,$opt_c,$opt_l);

# define our exit codes

my $SUCCESS = 0;
my $BAD_INPUT_FILE = 1;
my $INPUT_FILE_NOT_EXIST = 2;
my $BAD_OUTPUT_FORMAT = 3;

# change to dozenal digits; takes the scalar integer,
# returnst he dozenal digit character

sub dozenize($)
{
	if (($_[0] >= 0) && ($_[0] <= 9)) {
		return $_[0];
	} else {
		return 'X' if ($_[0] == 10);
		return 'E' if ($_[0] == 11);
	}
}

# convert integers from decmial to dozenal; takes the scalar
# integer, returns the scalar string

sub doz_int($)
{
	my $decnum = $_[0];
	my $holder = 1;
	my $doznum = "";

	while ($decnum >= 12) {
		$holder = $decnum % 12;
		$holder = dozenize($holder);
		$doznum .= $holder;
		$decnum /= 12;
	}
	$holder = $decnum % 12;
	$holder = dozenize($holder);
	$doznum .= $holder;
	return scalar reverse($doznum);
}

# converts single dozenal digits to decimal digit

sub decimalize($)
{
	if ($_[0] eq 'X') {
		return 10;
	} elsif ($_[0] eq 'E') {
		return 11;
	} else {
		return $_[0];
	}
}

# converts dozenal integers into decimal integers; takes the
# dozenal integer as a scalar, returns the decimal integer
# as a scalar

sub dec_int($)
{
	my @digits;
	my $len;
	my $decnum;
	my $exp = 0;

	@digits = split(//,$_[0]);
	$exp = $#digits;
	foreach my $var (@digits) {
		$decnum += decimalize($var) * (12**($exp--));
	}
	return $decnum;
}

# define our mod functions; both take two arguments, x and
# y, and return an integer

sub mod($$)
{
	return $_[0] - $_[1] * ($_[0] / $_[1]);
}
sub amod($$)
{
	return $_[1] + mod($_[0],-$_[1]);
}

# get the julian date; takes year, month, day

sub julday($$$)
{
	return 1721423.5 + Date_to_Days($_[0],$_[1],$_[2]) + 1;
}

# convert julian date back to gregorian date; takes the
# julian day, returns an array of year, month, day

sub jultogreg($)
{
	return Add_Delta_Days(1,1,1,$_[0] - 1721423.5 - 2);
}

# define @calendar; this array eats the contents of our
# data file

my $calfile;
my @calendar;
my @callist;			# holds unordered list from file(s)
my @months = qw( jan feb mar apr may jun jul aug sep oct nov dec );
my @monnums = qw( 31 28 31 30 31 30 31 31 30 31 30 31 );
my @wdays = qw( sun mon tue wed thu fri sat );
my $currdate = localtime;
my $year = doz_int($currdate->year);
my $month = -1;
my $day = -1;

# reads the files; takes a scalar list of files; returns
# number of lines read if success, otherwise dies returning
# error code

sub read_files($)
{
	my @filearray;			# takes filenames from opt_f
	my $calfile;			# file handle for read files
	my $j = 0;				# number of read non-comment lines

	@filearray = split(/,/,$_[0]);
	for (my $i = 0; $i <= $#filearray; $i++) {
		if (!-e $filearray[$i]) {
			print STDERR "dozcal error:  data file \"$filearray[$i]\" ";
			print STDERR "does not exist\n";
			exit $INPUT_FILE_NOT_EXIST;
		} else {
			open($calfile,"<","$filearray[$i]") || die $!;
			while (<$calfile>) {
				$callist[$j++] = $_ if ($_ !~ /^#/);
			}
		}
	}
	return $j;
}

# takes two scalars, the first is the date string in
# question, and the second the entire line; expands this
# into a list of julian days meeting the criteria, plus the
# remainders of the data lines; return the number of
# matching days

sub expand_dates($$)
{
	my $matches = 0;			# number of matching days to return
	my $udatestring = $_[0];# date string
	my $datestring = lc($_[0]);
	my $wholeline = $_[1];	# the whole line, including datestring
	my $hasmonth = 0;			# if there's a month
	my $haswday = 0;			# if there's a wday
	my $i;
	my $j;
	my $thedate;				# julian day in question
	my $theday = 1;			# local version of the day

	for ($i = 0; $i <= $#wdays; $i++) {
		if ($datestring =~ /$wdays[$i]/) {
			$haswday = 1;
			for ($j = 0; $j <= $#months; $j++) {
				if ($datestring =~ /$months[$j]/) {
					$hasmonth = 1;
					last;
				}
			}
			last;
		}
	}
	my $yeardays = (leap_year(dec_int($year))) ? 366 : 365;
	if (($haswday == 1) && ($hasmonth == 0)) {
		$theday+=1 while ($wdays[$i] ne lc(&day(1,$theday,dec_int($year))));
		for (my $k = $theday; $k <= $yeardays; $k+=7) {
			my ($themon,$theday) = get_month($k);
			$thedate = julday(dec_int($year),$themon+1,$theday);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
		}
	} elsif (($haswday == 1) && ($hasmonth == 1)) {
		$theday+=1 while 
			($wdays[$i] ne lc(&day($j+1,$theday,dec_int($year))));
		my $numdays = $monnums[$j];
		$numdays++ if (leap_year(dec_int($year)) && ($j == 1));
		for (my $k = $theday; $k <= $numdays; $k+=7) {
			$thedate = julday(dec_int($year),$j+1,$k);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
		}
	}
	#FIXME:  Need to finish this to fill the calendar array
}

# takes one scalar, yday; returns the month and day of that
# yday

sub get_month($)
{
	my $yday = $_[0];
	my $mon = 0;
	my $j = 0;
	my $theday = 1;

	for (my $i = 1; $i <= $yday; $i++) {
		$j++;
		if (($mon == 0) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 1) && ((($j == 28) || ($j == 29)))) {
			if ((leap_year(dec_int($year))) && ($j == 29)) {
				$mon++; $theday = $j;
				$j = 0;
			} elsif ((!leap_year(dec_int($year))) && ($j == 28)) {
				$mon++; $theday = $j;
				$j = 0;
			}
		} elsif (($mon == 2) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 3) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 4) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 5) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 6) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 7) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 8) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 9) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 10) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		}
	}
	$mon-- if ($j == 0);
	$j = $theday if ($j == 0);
	return ($mon,$j);
}

# takes the date requested on command line as scalar;
# modifies global date variables if necessary; returns 0 if
# success, 1 if failure

sub parse_date($)
{
	my $date = $_[0];

	if ($date =~ /([\dXE]{4,4})/) {
		$year = $1;
		$date =~ s/$1//;
	}
	if ($date =~ /([\dXE]{1,2})/) {
		$day = $1;
		$date =~ s/$1//;
	}
	$date = lc($date);
	for(my $i = 0; $i <= $#months; $i++) {
		$month = doz_int($i+1) if ($date =~ /$months[$i]/);
	}
}

# we know what this is for

sub main()
{
	my $lines;				# number of lines read from files
	my @line;				# a line from the data file

	$lines = read_files($opt_f);
	parse_date($opt_d) if $opt_d;
	for (my $i = 0; $i < $lines; $i++) {
		@line = split('\|',$callist[$i]);
		expand_dates($line[1],$callist[$i]);
	}
	print @calendar;
}

main();
