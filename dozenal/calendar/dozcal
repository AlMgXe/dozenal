#!/usr/bin/perl
# +AMDG  This document was begun on 8 Sept 11E8, the feast
# of the Nativity of the Blessed Virgin Mary and the Comm.
# of St. Hadrian, Martyr, and it is humbly dedicated to them
# for their prayers, and to the Sacred Heart of Jesus for
# His mercy.
#
# The main function for the decimal-to-dozenal convert.
#
# (C) Copyright 2012  Donald P. Goodman III
#
# This file is part of dozcal and the dozenal suite.
#
# dozcal is free software:  you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any
# later version.
#
# dozcal is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public
# License along with dozcal.  If not, see
# <http://www.gnu.org/licenses/>.

use strict;
use POSIX;
use String::Escape qw (unbackslash backslash);
use Time::Piece;
#use List::MoreUtils;
use Date::Day;
use Date::Easter;
use Date::Pcalc qw(:all);
use Getopt::Std;
getopts('f:d:o:thwls:');
our($opt_f,$opt_d,$opt_o,$opt_t,$opt_h,$opt_w,$opt_l,$opt_s);

my $INFIN = 999999999;
# define our exit codes

my $SUCCESS = 0;
my $BAD_INPUT_FILE = 1;
my $INPUT_FILE_NOT_EXIST = 2;
my $BAD_OUTPUT_FORMAT = 3;
my $BAD_MAIN_DATE = 4;
my $BAD_EXCEPTION_DATE = 5;
my $BAD_CONFIGFILE_OPTION = 6;
my $BAD_DATE_FOR_WEEKLY = 7;

# change to dozenal digits; takes the scalar integer,
# returnst he dozenal digit character

sub dozenize($)
{
	if (($_[0] >= 0) && ($_[0] <= 9)) {
		return $_[0];
	} else {
		return 'X' if ($_[0] == 10);
		return 'E' if ($_[0] == 11);
	}
}

# convert integers from decmial to dozenal; takes the scalar
# integer, returns the scalar string

sub doz_int($)
{
	my $decnum = $_[0];
	my $holder = 1;
	my $doznum = "";

	while ($decnum >= 12) {
		$holder = $decnum % 12;
		$holder = dozenize($holder);
		$doznum .= $holder;
		$decnum /= 12;
	}
	$holder = $decnum % 12;
	$holder = dozenize($holder);
	$doznum .= $holder;
	return scalar reverse($doznum);
}

# converts single dozenal digits to decimal digit

sub decimalize($)
{
	if ($_[0] eq 'X') {
		return 10;
	} elsif ($_[0] eq 'E') {
		return 11;
	} else {
		return $_[0];
	}
}

# converts dozenal integers into decimal integers; takes the
# dozenal integer as a scalar, returns the decimal integer
# as a scalar

sub dec_int($)
{
	my @digits;
	my $len;
	my $decnum;
	my $exp = 0;

	@digits = split(//,$_[0]);
	$exp = $#digits;
	foreach my $var (@digits) {
		$decnum += decimalize($var) * (12**($exp--));
	}
	return $decnum;
}

# define our mod functions; both take two arguments, x and
# y, and return an integer

sub mod($$)
{
	return $_[0] - $_[1] * ($_[0] / $_[1]);
}
sub amod($$)
{
	return $_[1] + mod($_[0],-$_[1]);
}

# get the julian date; takes year, month, day

sub julday($$$)
{
	return 1721423.5 + Date_to_Days($_[0],$_[1],$_[2]) + 1;
}

# convert julian date back to gregorian date; takes the
# julian day, returns an array of year, month, day

sub jultogreg($)
{
	return Add_Delta_Days(1,1,1,$_[0] - 1721423.5 - 2);
}

# define @calendar; this array eats the contents of our
# data file; also define a variety of globally useful
# variables

my $calfile;
my @calendar;
my @callist;			# holds unordered list from file(s)
my @months = qw( jan feb mar apr may jun jul aug sep oct nov dec );
my @monnums = qw( 31 28 31 30 31 30 31 31 30 31 30 31 );
my @wdays = qw( sun mon tue wed thu fri sat );
my $currdate = localtime;
my $year = doz_int($currdate->year);
my $month = -1;
my $day = -1;

# define the default date format variable; this can be
# changed by command line or by config file

my $date_format = "%d %b %Y";

# configure options from the config file; takes a scalar,
# returns nothing

sub config_opts($)
{
	my $option = $_[0];

	chomp($option);
	if ($option =~ /^%DATEFORM:\s*(.*)$/) {
		$date_format = $1;
	} else {
		print STDERR "dozcal:  error:  dozcal does not ";
		print STDERR "recognize the configure option ";
		print STDERR "\n\t\"$option\"\n";
		exit $BAD_CONFIGFILE_OPTION;
	}
}

# reads the files; takes a scalar list of files; returns
# number of lines read if success, otherwise dies returning
# error code

sub read_files($)
{
	my @filearray;			# takes filenames from opt_f
	my $calfile;			# file handle for read files
	my $j = 0;				# number of read non-comment lines

	@filearray = split(/,/,$_[0]);
	for (my $i = 0; $i <= $#filearray; $i++) {
		if (!-e $filearray[$i]) {
			print STDERR "dozcal error:  data file \"$filearray[$i]\" ";
			print STDERR "does not exist\n";
			exit $INPUT_FILE_NOT_EXIST;
		} else {
			open($calfile,"<","$filearray[$i]") || die $!;
			while (<$calfile>) {
				if ($_ =~ /^%/) {
					config_opts($_);
					next;
				}
				$callist[$j++] = $_ if ($_ !~ /^#/);
			}
		}
	}
	return $j;
}

# takes two scalars, the first is the date string in
# question, and the second the entire line; expands this
# into a list of julian days meeting the criteria, plus the
# remainders of the data lines; returns zero if success, one
# if failure

sub expand_dates($$)
{
	my $matches = 0;			# number of matching days to return
	my $udatestring = $_[0];# date string
	my $datestring = lc($_[0]);
	my $wholeline = $_[1];	# the whole line, including datestring
	my $hasmonth = 0;			# if there's a month
	my $haswday = 0;			# if there's a wday
	my $i;
	my $j;
	my $thedate;				# julian day in question
	my $theday = 1;			# local version of the day
	my $yeardays;
	my $theyear;
	my $success = 1;			# error; set to zero if works

	for ($i = 0; $i <= $#wdays; $i++) {
		if ($datestring =~ /$wdays[$i]/) {
			$haswday = 1;
			last;
		}
	}
	for ($j = 0; $j <= $#months; $j++) {
		if ($datestring =~ /$months[$j]/) {
			$hasmonth = 1;
			last;
		}
	}
	if ($datestring =~ /([\dxe]{4,4})/) {
		$theyear = uc($1);
	} else {
		$theyear = $year;
	}
	$yeardays = (leap_year(dec_int($theyear))) ? 366 : 365;
	if (($haswday == 1) && ($hasmonth == 0)) {
		$theday+=1 while ($wdays[$i] ne 
			lc(&day(1,$theday,dec_int($theyear))));
		for (my $k = $theday; $k <= $yeardays; $k+=7) {
			my ($themon,$theday) = get_month($k);
			$thedate = julday(dec_int($theyear),$themon+1,$theday);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
			$success = 0;
		}
	} elsif (($haswday == 1) && ($hasmonth == 1)) {
		$theday+=1 while 
			($wdays[$i] ne lc(&day($j+1,$theday,dec_int($theyear))));
		my $numdays = $monnums[$j];
		$numdays++ if (leap_year(dec_int($theyear)) && ($j == 1));
		for (my $k = $theday; $k <= $numdays; $k+=7) {
			$thedate = julday(dec_int($theyear),$j+1,$k);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
			$success = 0;
		}
	} elsif (($hasmonth == 1) && ($haswday == 0)) {
		if ($datestring =~ /--/) {
			my $firstdate; my $lastdate;
			($firstdate,$lastdate) = ($datestring =~ /(.*)--(.*)/);
			$firstdate = spec_date($firstdate);
			$lastdate = spec_date($lastdate);
			while ($firstdate <= $lastdate) {
				my $tmpline = $wholeline;
				$tmpline =~ s/$udatestring/$firstdate/;
				push(@calendar,$tmpline);
				$firstdate++;
			}
			$success = 0;
		} else {
			$thedate = spec_date($datestring);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
			$success = 0;
		}
	}
	return $success;
}

# takes a date string; returns the julian day associated
# therewith

sub spec_date($)
{
	my $date = $_[0];
	my $theyear;
	my $theday;
	my $themon;

	if ($date =~ /([\dxe]{4,4})/) {
		$theyear = uc($1);
	} else {
		$theyear = $year;
	}
	if ($date =~ /([\dxe]{1,2})/) {
		$theday = uc($1);
	} else {
		$theday = 1;
	}
	for (my $i = 0; $i <= $#months; $i++) {
		$themon = $i if ($date =~ /$months[$i]/);
		last if ($date =~ /$months[$i]/);
	}
	return julday(dec_int($theyear),$themon+1,dec_int($theday));
}

# takes one scalar, yday; returns the month and day of that
# yday

sub get_month($)
{
	my $yday = $_[0];
	my $mon = 0;
	my $j = 0;
	my $theday = 1;

	for (my $i = 1; $i <= $yday; $i++) {
		$j++;
		if (($mon == 0) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 1) && ((($j == 28) || ($j == 29)))) {
			if ((leap_year(dec_int($year))) && ($j == 29)) {
				$mon++; $theday = $j;
				$j = 0;
			} elsif ((!leap_year(dec_int($year))) && ($j == 28)) {
				$mon++; $theday = $j;
				$j = 0;
			}
		} elsif (($mon == 2) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 3) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 4) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 5) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 6) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 7) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 8) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 9) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 10) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		}
	}
	$mon-- if ($j == 0);
	$j = $theday if ($j == 0);
	return ($mon,$j);
}

# takes the date requested on command line as scalar;
# modifies global date variables if necessary; returns the
# start and end julian dates of the requested period

sub parse_date($)
{
	my $date = $_[0];
	my $theday;
	my $themon = -1;
	my $theyear;
	my $startdate;
	my $enddate;
	my $numdays;

	if ($date =~ /([\dXE]{4,4})/) {
		$year = $theyear = $1;
		$date =~ s/$1//;
	}
	if ($date =~ /([\dXE]{1,2})/) {
		$theday = $1;
		$date =~ s/$1//;
	}
	$date = lc($date);
	for(my $i = 0; $i <= $#months; $i++) {
		$themon = $i+1 if ($date =~ /$months[$i]/);
	}
	if (($themon == -1) && ($theday eq "")) {
		$startdate = julday(dec_int($theyear),1,1);
		$enddate = julday(dec_int($theyear),12,31);
	} elsif (($theday eq "") && ($themon != -1)) {
		$startdate = julday(dec_int($theyear),$themon,1);
		$numdays = $monnums[$themon-1];
		$numdays++ if (($themon == 2) && (leap_year(dec_int($theyear))));
		$enddate = julday(dec_int($theyear),$themon,$numdays);
	} elsif (($theday ne "") && ($themon != -1)) {
		$startdate = julday(dec_int($theyear),$themon,dec_int($theday));
		$enddate = $startdate;
	} else {
		print STDERR "dozcal:  error:  date string \"$date\" ";
		print STDERR "is not understood; must include at least \n";
		print STDERR "four-digit year; if month is included, ";
		print STDERR "must be alphabetic with at least three \n";
		print STDERR "letters\n";
	}
	return ($startdate,$enddate);
}

# remove exceptions from the calendar results; takes the
# good array and the exception array, returns nothing

sub remove_exceptions(\@\@)
{
	my @excepts = @{$_[1]};
	my @goods = @{$_[0]};
	my @line;

	foreach my $var (@excepts) {
		@line = split('\|',$var);
		for (my $i = 0; $i <= $#goods; $i++) {
			if (($goods[$i] =~ /$line[3]/) && ($goods[$i] =~ /$line[0]/)) {
				splice(@goods,$i,1);
			}
		}
	}
	return @goods;
}

# subtract "2" from all times to make them sortable; takes
# nothing, receives nothing

sub shrink_time()
{
	my $hour;
	my $bicia;
	my $newnum;

	for (my $i = 0; $i <= $#calendar; $i++) {
		($hour,$bicia) = ($calendar[$i][2] =~ 
			/([\dXE]{1,2});([\dXE]{1,2})/);
		next if ($hour eq "");
		$hour = dec_int($hour) - 2;
		$bicia = dec_int($bicia) - 2;
		$newnum = $hour.".".$bicia;
		$calendar[$i][2] = $newnum;
	}
}

# adds "2" to all times to make them dozenal again; takes
# nothing, returns nothing

sub unshrink_time()
{
	my $hour;
	my $bicia;
	my $newnum;

	for (my $i = 0; $i <= $#calendar; $i++) {
		($hour,$bicia) = ($calendar[$i][2] =~ 
			/([\dXE]{1,2})\.([-\dXE]{1,2})/);
		next if ($hour eq "");
		$hour += 2; $bicia += 2;
		$newnum = $hour.";".$bicia;
		$hour = doz_int($hour); $bicia = doz_int($bicia);
		$hour = "0".$hour if ($hour =~ /^[\dXE]$/);
		$bicia = "0".$bicia if ($bicia =~ /^[\dXE]$/);
		$newnum = $hour.";".$bicia;
		$calendar[$i][2] = $newnum;
	}
}

# trims the calendar array to include only the requested
# date range ($opt_d); takes the start and end date in
# julian days, returns nothing

sub limit_to_date($$)
{
	my $startdate = $_[0];
	my $enddate = $_[1];
	my $i = 0;

	while ($i <= $#calendar) {
		if (($calendar[$i][1] < $startdate) || 
		($calendar[$i][1] > $enddate)) {
			splice(@calendar,$i,1);
		} else {
			$i++;
		}
	}
}

# configures the output for plain text results; takes no
# arguments, returns nothinga

sub text_output()
{
	for (my $i = 0; $i <= $#calendar; $i++) {
		print "$calendar[$i][1]:  ";
		if ($calendar[$i][2] ne "") {
			print "$calendar[$i][2]:  ";
		} else {
			print "        ";
		}
		print "$calendar[$i][0]";
		if ($opt_t) {
			my $type = $calendar[$i][4];
			chomp $type;
			print " %$type% ";
		}
		print "\n";
	}
}

# configures the output for basic format plain text results;
# takes no arguments, returns nothing

sub basic_output()
{
	my $lastdate = -1;	# keeps track of prior date

	for (my $i = 0; $i <= $#calendar; $i++) {
		if ($calendar[$i][1] ne $lastdate) {
			print "$calendar[$i][1]\n";
			$lastdate = $calendar[$i][1];
		}
		if ($calendar[$i][2] ne '') {
			print "\t$calendar[$i][2]:\t";
		} else {
			print "\t     \t";
		}
		print "$calendar[$i][0]\n";
	}
}

# produce weekly output; just takes the first day of the
# requested date range and returns that week; takes
# startdate and enddate, returns the new startdate and
# enddate

sub weekly_output($$)
{
	my $start = $_[0]; my $end = $_[1];
	my $theyear; my $themon; my $theday;
	my $weekday = -1;
	my $i; my $j;
	my $startweek = 0;	# to start week on Sunday
	my $distance;			# distance to start of week

	if ($opt_s) {
		for ($j = 0; $j <= $#wdays; $j++) {
			last if (lc($opt_s) =~ /$wdays[$j]/);
		}
		$startweek = $j;
	}
	if ($start != $end) {
		print STDERR "dozcal:  error:  when using the \"-w\" ";
		print STDERR "option, an individual date must be \n";
		print STDERR "requested; e.g., \"-d\'1E Apr 11E8\'\"\n";
		exit $BAD_DATE_FOR_WEEKLY;
	}
	($theyear,$themon,$theday) = jultogreg($start);
	$weekday = lc(&day($themon,$theday,$theyear));
	for ($j = 0; $j <= $#wdays; $j++) {
		last if ($weekday =~ /$wdays[$j]/);
	}
	$start = $start - ($j + (7 - $startweek)) if ($startweek > $j);
	$start = $start - ($j - $startweek) if ($startweek < $j);
	return ($start,$start+7);
}

# the help function; exits successfully

sub help_func()
{
	print <<ENDHELP;
dozcal v1.0, part of the dozenal suite.

Copyright (C) 2010, 2011  Donald P. Goodman III

License GPLv3+:  GNU GPL version 3 or later
(<http://gnu.org/licenses/gpl.html>).  This is free
software: you are free to change and redistribute it.  There
is NO WARRANTY, to the extent permitted by law.

dozcal is designed to facilitate the keeping of calendars in
dozenal.

DATA FILE

The data file(s) are what are read into memory by dozcal to
populate the calendar.  These can be as many as are desired,
listed to dozcal in a comma-separated list.  E.g.:

	dozcal -f "oct_11E8,nov_11E8,dec_11E8"

The final results will be sorted and ordered without regard
to what file they came from.

The format of the data file is quite simple; each line is an
entry for the calendar, and it consists of fields separated
by the pipe character ("|").  The fields are defined as
follows:

	Name | Date(s) | Time(s) | Exceptions | Type

The name is simply what you'd write into a calendar; e.g.,
"staff meeting" or "workout."  The date(s) are the dates on
which you wish these things to be listed; more on that later
in the section "DATE FORMATS".  The time is, of course, the
time on the date this will be happening.  "Exceptions" are
those exceptions to t date given in field 2; e.g., if you
want something listed on all Wednesdays in September, but
not one particular Wednesday, that exception would be listed
here.

Finally, the type.  This is a largely arbitrary string used
primarily for ordering results if the date and time are
otherwise the same; this information could also be used for
formatting the results by a different script.  It is often
wise to use a simple word---"meeting," "event," or
similar---and prefix to it a digit---"1meeting,"
"2meeting"---for ordering purposes.  So if you have three
events at the same date and time, like so:

	Staff Meeting (event)
	Job Picnic (2event)
	Workout (1event)

They would be ordered according to this "type" field, like
so:

	Workout (1event)
	Job Picnic (2event)
	Staff Meeting (event)

"1" comes before "2," which comes before "e."  This is
standard ASCII-text ordering.

Options can be specified in lines which begin with the
character "%".  So, for example, to change the default
format of the date to list a full, rather than abbreviated,
month, simply put this line in your file:

	%DATEFORM:  %d %B %Y

Since dozcal is really a wrapper around dozdate, you can use
any valid dozdate format string for this.

DATE FORMATS

Dates can be provided to dozcal in a number of ways, always
with the "-d" option on the command line:

	*  Weekdays.  These can be listed by themselves, in which
	case dozcal will assume that it means all of those
	weekdays in the year; or with a month, in which case
	dozcal only expands this to those weekdays in a given
	month.  
	*  Months.  You can ask dozcal to give you an entire
	month at a time.  You must list a year with it so that
	dozcal knows what you mean.
	*  Years.  You can tell dozcal to give you an entire
	year's worth of results at once.
	*  Specific dates.  You can tell dozcal to give you just
	the results  for a specific date.  If you do this,  you
	can also use the "-w" option, possibly with the "-s"
	option, for which see below.

OPTIONS
	-f	The files that will be read from for data
		information; multiple files can be listed in a
		comma-separated list.  Take the file(s) as an
		argument.
	-d	The dates you want returned to you.  See above, "DATE
		FORMATS," for more details.  Takes the requested date
		string as an argument.
	-t	Outputs the last column of a data line, the "type"
		field, surrounded by "%" characters in the output.
		Useful when dozcals' output is going to be filtered by
		another program and can use that information for
		formatting or other tasks.
	-l	LaTeX formatting; prepares the output for use with
		latexcal, a helper script which builds a professional
		and beautifully typeset calendar in LaTeX.
	-w	Weekly; gives as output the entire week which includes
		the requested date, rather than only the date itself.
		This can only be used in conjunction with a specific
		date given with the "-d" option.
	-s	Starting day; tells dozcal which day it should
		consider the start  of the week.  Only works if done
		in conjunction with the "-w" option.  (dozcal really
		has no concept of the week unless "-w" is given.)  Use
		a string containing at least the first three letters
		of the weekday you want to be the start of the week.
		Defaults to Sunday.

ENDHELP
	exit 0;
}

# format for HTML output

sub html_output()
{
	my $weekday;
	my $i; my $j = 0; my $k;
	my $lastdate;

	print "<html><body>\n";
	print "<style>\n";
	print "table {\n";
	print "\tborder:  2px;\n";
	print "\ttable-layout:  fixed;\n";
	print "}\n";
	print "td {\n";
	print "\twidth:  14%;\n";
	print "\tvertical-align:  top;\n";
	print "\tfont-size:  70%;\n";
	print "}\n";
	print ".heading {\n";
	print "\tfont-weight:  bold;\n";
	print "\tfont-size:  120%;\n";
	print "}\n";
	print ".hanger {\n";
	print "\tpadding-left:  1em;\n";
	print "\ttext-indent:  -1em;\n";
	print "}\n";
	print "</style>\n";
	if (!$opt_w) {
		print "<table border=\"2px\">\n";
		print "<tr><th colspan=\"7\">Calendar</th></tr>\n";
		$weekday = lc(qx( dozdate -d"$calendar[0][1]" "%a"));
		$j++ while ($weekday !~ /$wdays[$j]/);
		print "<tr>\n";
		$k = 0;
		print "<td></td>\n" while ($k++ != $j);
		print "<td><center><span class=\"heading\">$calendar[0][1]</span></center>\n";
		$lastdate = $calendar[0][1];
		for ($i = 0; $i <= $#calendar; $i++) {
			if ($calendar[$i][1] eq $lastdate) {
				print "<div class=\"hanger\">\n";
				print "$calendar[$i][2]:  \n" if $calendar[$i][2] ne "";
				print "$calendar[$i][0]</div>\n";
			} else {
				$j++;
				print "</tr><tr>\n" if ((($j % 7) == 0) && ($j != 0));
				print "<td><center><span class=\"heading\">$calendar[$i][1]</span></center>\n";
				print "<div class=\"hanger\">\n";
				print "$calendar[$i][2]:  \n" if $calendar[$i][2] ne "";
				print "$calendar[$i][0]</div>\n";
				$lastdate = $calendar[$i][1];
			}
		}
		print "</table></html>";
	}
}

# we know what this is for

sub main()
{
	my $lines;				# number of lines read from files
	my @line;				# a line from the data file
	my @goodlines;			# array of dates
	my @exceptions;		# array of exceptions
	my $fault = 0;			# set to one if error
	my $startdate = 0;	# if date range is requested
	my $enddate = 0;		# if date range is requested

	help_func() if ($opt_h);
	$lines = read_files($opt_f);
	($startdate,$enddate) = parse_date($opt_d) if $opt_d;
	$enddate = $INFIN if ($enddate == 0);
	($startdate,$enddate) = weekly_output($startdate,$enddate) 
		if ($opt_w);
	for (my $i = 0; $i < $lines; $i++) {
		@line = split('\|',$callist[$i]);
		$fault = expand_dates($line[1],$callist[$i]);
		if ($fault == 1) {
			chomp($callist[$i]);
			print STDERR "dozcal:  error:  the following line's ";
			print STDERR "main date is malformed:\n\t \"$callist[$i]\"";
			exit $BAD_MAIN_DATE;
		}
	} # next, do the exceptions
	@goodlines = @calendar;
	@calendar = ();
	for (my $i = 0; $i < $lines; $i++) {
		@line = split('\|',$callist[$i]);
		$fault = expand_dates($line[3],$callist[$i]);
		if (($fault == 1) && ($callist[$i] != "")) {
			chomp($callist[$i]);
			print STDERR "dozcal:  error:  the following line's ";
			print STDERR "exception date is malformed:\n\t \"$callist[$i]\"";
			exit $BAD_EXCEPTION_DATE;
		} elsif (($fault == 1) && ($callist[$i] == "")) {
			$fault = 0;
		}
	}
	@goodlines = remove_exceptions(@goodlines,@calendar);
	@calendar = ();
	for (my $i = 0; $i <= $#goodlines; $i++) {
		push @{$calendar[$i]},split('\|',$goodlines[$i]);
	}
	limit_to_date($startdate,$enddate);
	shrink_time();
	@calendar = sort { $a->[1] <=> $b->[1] || $a->[2] <=>
		$b->[2] || $a->[4] cmp $b->[4] } @calendar;
	unshrink_time();
	$date_format = "%Y/%m/%d" if ($opt_l);
	for (my $i = 0; $i <= $#calendar; $i++) {
		my ($theyear,$themon,$theday) = jultogreg($calendar[$i][1]);
		$theyear = doz_int($theyear); $themon = doz_int($themon);
		$theday = doz_int($theday);
		my $thedate = 
			qx( dozdate "$date_format" -d"$theyear-$themon-$theday" );
		chomp($thedate);
		$calendar[$i][1] = $thedate;
	}
	text_output() if ((!$opt_o) || ($opt_o eq 'text'));
	basic_output() if ($opt_o eq 'basic');
	html_output() if ($opt_o eq 'html');
}

main();
