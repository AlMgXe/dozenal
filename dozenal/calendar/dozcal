#!/usr/bin/perl
# +AMDG  This document was begun on 8 Sept 11E8, the feast
# of the Nativity of the Blessed Virgin Mary and the Comm.
# of St. Hadrian, Martyr, and it is humbly dedicated to them
# for their prayers, and to the Sacred Heart of Jesus for
# His mercy.

use strict;
use POSIX;
use String::Escape qw (unbackslash backslash);
use Time::Piece;
#use List::MoreUtils;
use Date::Day;
use Date::Easter;
use Date::Pcalc qw(:all);
use Getopt::Std;
getopts('f:d:o:thcl');
our($opt_f,$opt_d,$opt_o,$opt_t,$opt_h,$opt_c,$opt_l);

# define our exit codes

my $SUCCESS = 0;
my $BAD_INPUT_FILE = 1;
my $INPUT_FILE_NOT_EXIST = 2;
my $BAD_OUTPUT_FORMAT = 3;
my $BAD_MAIN_DATE = 4;
my $BAD_EXCEPTION_DATE = 5;

# change to dozenal digits; takes the scalar integer,
# returnst he dozenal digit character

sub dozenize($)
{
	if (($_[0] >= 0) && ($_[0] <= 9)) {
		return $_[0];
	} else {
		return 'X' if ($_[0] == 10);
		return 'E' if ($_[0] == 11);
	}
}

# convert integers from decmial to dozenal; takes the scalar
# integer, returns the scalar string

sub doz_int($)
{
	my $decnum = $_[0];
	my $holder = 1;
	my $doznum = "";

	while ($decnum >= 12) {
		$holder = $decnum % 12;
		$holder = dozenize($holder);
		$doznum .= $holder;
		$decnum /= 12;
	}
	$holder = $decnum % 12;
	$holder = dozenize($holder);
	$doznum .= $holder;
	return scalar reverse($doznum);
}

# converts single dozenal digits to decimal digit

sub decimalize($)
{
	if ($_[0] eq 'X') {
		return 10;
	} elsif ($_[0] eq 'E') {
		return 11;
	} else {
		return $_[0];
	}
}

# converts dozenal integers into decimal integers; takes the
# dozenal integer as a scalar, returns the decimal integer
# as a scalar

sub dec_int($)
{
	my @digits;
	my $len;
	my $decnum;
	my $exp = 0;

	@digits = split(//,$_[0]);
	$exp = $#digits;
	foreach my $var (@digits) {
		$decnum += decimalize($var) * (12**($exp--));
	}
	return $decnum;
}

# define our mod functions; both take two arguments, x and
# y, and return an integer

sub mod($$)
{
	return $_[0] - $_[1] * ($_[0] / $_[1]);
}
sub amod($$)
{
	return $_[1] + mod($_[0],-$_[1]);
}

# get the julian date; takes year, month, day

sub julday($$$)
{
	return 1721423.5 + Date_to_Days($_[0],$_[1],$_[2]) + 1;
}

# convert julian date back to gregorian date; takes the
# julian day, returns an array of year, month, day

sub jultogreg($)
{
	return Add_Delta_Days(1,1,1,$_[0] - 1721423.5 - 2);
}

# define @calendar; this array eats the contents of our
# data file

my $calfile;
my @calendar;
my @callist;			# holds unordered list from file(s)
my @months = qw( jan feb mar apr may jun jul aug sep oct nov dec );
my @monnums = qw( 31 28 31 30 31 30 31 31 30 31 30 31 );
my @wdays = qw( sun mon tue wed thu fri sat );
my $currdate = localtime;
my $year = doz_int($currdate->year);
my $month = -1;
my $day = -1;

# reads the files; takes a scalar list of files; returns
# number of lines read if success, otherwise dies returning
# error code

sub read_files($)
{
	my @filearray;			# takes filenames from opt_f
	my $calfile;			# file handle for read files
	my $j = 0;				# number of read non-comment lines

	@filearray = split(/,/,$_[0]);
	for (my $i = 0; $i <= $#filearray; $i++) {
		if (!-e $filearray[$i]) {
			print STDERR "dozcal error:  data file \"$filearray[$i]\" ";
			print STDERR "does not exist\n";
			exit $INPUT_FILE_NOT_EXIST;
		} else {
			open($calfile,"<","$filearray[$i]") || die $!;
			while (<$calfile>) {
				$callist[$j++] = $_ if ($_ !~ /^#/);
			}
		}
	}
	return $j;
}

# takes two scalars, the first is the date string in
# question, and the second the entire line; expands this
# into a list of julian days meeting the criteria, plus the
# remainders of the data lines; returns zero if success, one
# if failure

sub expand_dates($$)
{
	my $matches = 0;			# number of matching days to return
	my $udatestring = $_[0];# date string
	my $datestring = lc($_[0]);
	my $wholeline = $_[1];	# the whole line, including datestring
	my $hasmonth = 0;			# if there's a month
	my $haswday = 0;			# if there's a wday
	my $i;
	my $j;
	my $thedate;				# julian day in question
	my $theday = 1;			# local version of the day
	my $yeardays;
	my $theyear;
	my $success = 1;			# error; set to zero if works

	for ($i = 0; $i <= $#wdays; $i++) {
		if ($datestring =~ /$wdays[$i]/) {
			$haswday = 1;
			last;
		}
	}
	for ($j = 0; $j <= $#months; $j++) {
		if ($datestring =~ /$months[$j]/) {
			$hasmonth = 1;
			last;
		}
	}
	if ($datestring =~ /([\dxe]{4,4})/) {
		$theyear = uc($1);
	} else {
		$theyear = $year;
	}
	$yeardays = (leap_year(dec_int($theyear))) ? 366 : 365;
	if (($haswday == 1) && ($hasmonth == 0)) {
		$theday+=1 while ($wdays[$i] ne 
			lc(&day(1,$theday,dec_int($theyear))));
		for (my $k = $theday; $k <= $yeardays; $k+=7) {
			my ($themon,$theday) = get_month($k);
			$thedate = julday(dec_int($theyear),$themon+1,$theday);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
			$success = 0;
		}
	} elsif (($haswday == 1) && ($hasmonth == 1)) {
		$theday+=1 while 
			($wdays[$i] ne lc(&day($j+1,$theday,dec_int($theyear))));
		my $numdays = $monnums[$j];
		$numdays++ if (leap_year(dec_int($theyear)) && ($j == 1));
		for (my $k = $theday; $k <= $numdays; $k+=7) {
			$thedate = julday(dec_int($theyear),$j+1,$k);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
			$success = 0;
		}
	} elsif (($hasmonth == 1) && ($haswday == 0)) {
		if ($datestring =~ /--/) {
			my $firstdate; my $lastdate;
			($firstdate,$lastdate) = ($datestring =~ /(.*)--(.*)/);
			$firstdate = spec_date($firstdate);
			$lastdate = spec_date($lastdate);
			while ($firstdate <= $lastdate) {
				my $tmpline = $wholeline;
				$tmpline =~ s/$udatestring/$firstdate/;
				push(@calendar,$tmpline);
				$firstdate++;
			}
			$success = 0;
		} else {
			$thedate = spec_date($datestring);
			my $tmpline = $wholeline;
			$tmpline =~ s/$udatestring/$thedate/;
			push(@calendar,$tmpline);
			$success = 0;
		}
	}
	return $success;
}

# takes a date string; returns the julian day associated
# therewith

sub spec_date($)
{
	my $date = $_[0];
	my $theyear;
	my $theday;
	my $themon;

	if ($date =~ /([\dxe]{4,4})/) {
		$theyear = uc($1);
	} else {
		$theyear = $year;
	}
	if ($date =~ /([\dxe]{1,2})/) {
		$theday = uc($1);
	} else {
		$theday = 1;
	}
	for (my $i = 0; $i <= $#months; $i++) {
		$themon = $i if ($date =~ /$months[$i]/);
		last if ($date =~ /$months[$i]/);
	}
	return julday(dec_int($theyear),$themon+1,dec_int($theday));
}

# takes one scalar, yday; returns the month and day of that
# yday

sub get_month($)
{
	my $yday = $_[0];
	my $mon = 0;
	my $j = 0;
	my $theday = 1;

	for (my $i = 1; $i <= $yday; $i++) {
		$j++;
		if (($mon == 0) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 1) && ((($j == 28) || ($j == 29)))) {
			if ((leap_year(dec_int($year))) && ($j == 29)) {
				$mon++; $theday = $j;
				$j = 0;
			} elsif ((!leap_year(dec_int($year))) && ($j == 28)) {
				$mon++; $theday = $j;
				$j = 0;
			}
		} elsif (($mon == 2) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 3) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 4) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 5) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 6) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 7) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 8) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 9) && ($j == 31)) {
			$mon++; $theday = $j;
			$j = 0;
		} elsif (($mon == 10) && ($j == 30)) {
			$mon++; $theday = $j;
			$j = 0;
		}
	}
	$mon-- if ($j == 0);
	$j = $theday if ($j == 0);
	return ($mon,$j);
}

# takes the date requested on command line as scalar;
# modifies global date variables if necessary; returns 0 if
# success, 1 if failure

sub parse_date($)
{
	my $date = $_[0];

	if ($date =~ /([\dXE]{4,4})/) {
		$year = $1;
		$date =~ s/$1//;
	}
	if ($date =~ /([\dXE]{1,2})/) {
		$day = $1;
		$date =~ s/$1//;
	}
	$date = lc($date);
	for(my $i = 0; $i <= $#months; $i++) {
		$month = doz_int($i+1) if ($date =~ /$months[$i]/);
	}
}

# remove exceptions from the calendar results; takes the
# good array and the exception array, returns nothing

sub remove_exceptions(\@\@)
{
	my @excepts = @{$_[1]};
	my @goods = @{$_[0]};
	my @line;

	foreach my $var (@excepts) {
		@line = split('\|',$var);
		for (my $i = 0; $i <= $#goods; $i++) {
			if (($goods[$i] =~ /$line[3]/) && ($goods[$i] =~ /$line[0]/)) {
				splice(@goods,$i,1);
			}
		}
	}
	return @goods;
}

# subtract "2" from all times to make them sortable; takes
# nothing, receives nothing

sub shrink_time()
{
	my $hour;
	my $bicia;
	my $newnum;

	for (my $i = 0; $i <= $#calendar; $i++) {
		($hour,$bicia) = ($calendar[$i][2] =~ 
			/([\dXE]{1,2});([\dXE]{1,2})/);
		next if ($hour eq "");
		$hour = dec_int($hour) - 2;
		$bicia = dec_int($bicia) - 2;
		$newnum = $hour.".".$bicia;
		$calendar[$i][2] = $newnum;
	}
}

# adds "2" to all times to make them dozenal again; takes
# nothing, returns nothing

sub unshrink_time()
{
	my $hour;
	my $bicia;
	my $newnum;

	for (my $i = 0; $i <= $#calendar; $i++) {
		($hour,$bicia) = ($calendar[$i][2] =~ 
			/([\dXE]{1,2})\.([-\dXE]{1,2})/);
		next if ($hour eq "");
		$hour += 2; $bicia += 2;
		$newnum = $hour.";".$bicia;
		$hour = doz_int($hour); $bicia = doz_int($bicia);
		$hour = "0".$hour if ($hour =~ /^[\dXE]$/);
		$bicia = "0".$bicia if ($bicia =~ /^[\dXE]$/);
		$newnum = $hour.";".$bicia;
		$calendar[$i][2] = $newnum;
	}
}

# we know what this is for

sub main()
{
	my $lines;				# number of lines read from files
	my @line;				# a line from the data file
	my @goodlines;			# array of dates
	my @exceptions;		# array of exceptions
	my $fault = 0;			# set to one if error

	$lines = read_files($opt_f);
	parse_date($opt_d) if $opt_d;
	for (my $i = 0; $i < $lines; $i++) {
		@line = split('\|',$callist[$i]);
		$fault = expand_dates($line[1],$callist[$i]);
		if ($fault == 1) {
			chomp($callist[$i]);
			print STDERR "dozcal:  error:  the following line's ";
			print STDERR "main date is malformed:\n\t \"$callist[$i]\"";
			exit $BAD_MAIN_DATE;
		}
	} # next, do the exceptions
	@goodlines = @calendar;
	@calendar = ();
	for (my $i = 0; $i < $lines; $i++) {
		@line = split('\|',$callist[$i]);
		$fault = expand_dates($line[3],$callist[$i]);
		if (($fault == 1) && ($callist[$i] != "")) {
			chomp($callist[$i]);
			print STDERR "dozcal:  error:  the following line's ";
			print STDERR "exception date is malformed:\n\t \"$callist[$i]\"";
			exit $BAD_EXCEPTION_DATE;
		} elsif (($fault == 1) && ($callist[$i] == "")) {
			$fault = 0;
		}
	}
	@goodlines = remove_exceptions(@goodlines,@calendar);
	@calendar = ();
	for (my $i = 0; $i <= $#goodlines; $i++) {
		push @{$calendar[$i]},split('\|',$goodlines[$i]);
	}
	shrink_time();
	@calendar = sort { $a->[1] <=> $b->[1] || $a->[2] <=>
		$b->[2] || $a->[4] cmp $b->[4] } @calendar;
	unshrink_time();
	for (my $i = 0; $i <= $#calendar; $i++) {
		for (my $j = 0; $j < 5; $j++) {
			print $calendar[$i][$j];
		}
	}
}

main();
